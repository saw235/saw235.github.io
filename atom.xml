<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Saw</title>
  <id>http://saw235.github.io</id>
  <link href="http://saw235.github.io" />
  <link href="http://saw235.github.io/atom.xml" rel="self" />
  <updated>2018-12-12T01:33:20+08:00</updated>
  <rights>Copyright 2014, Xue Zheng</rights>
  <author>
    <name>Xue Zheng</name>
  </author>
  
    <entry>
      <title>New layout - Hikari Theme</title>
      <link href="http://saw235.github.io/2018/12/12/hikari-layout/" />
      <summary type="html">&lt;p&gt;Finally got the motivation to come back and do some updates to this blog. I can’t believe it. It has actually been two years since I last updated!
As you can see, I have opted into using this minimalistic Hikari jekyll theme for my blog, which suits me.&lt;/p&gt;

&lt;p&gt;I thought about using a medium-ish kind of theme but have decided against it at this point in time. It does look a lot more nicer but I wanted to focus on actually building quality blog content first instead of hiding underneath a nice blog UI.&lt;/p&gt;

&lt;p&gt;Anyhow the last two years has been really busy and I’ve managed to get myself into an even busier schedule by juggling between work, friends and side projects. I have finally gotten into the groove of things and seriously vow to keep updating this blog at least once per month! I have always wanted to complete the eulerproject math/code challenges so I think I will start with those.&lt;/p&gt;
</summary>
      <id>http://saw235.github.io/2018/12/12/hikari-layout/</id>
      <updated>2018-12-12T07:41:00+08:00</updated>
      <author>
        <name>Xue Zheng</name>
      </author>
    </entry>
  
    <entry>
      <title>Real-time Image Filtering using FPGA</title>
      <link href="http://saw235.github.io/2017/12/30/fpga-image-processing/" />
      <summary type="html">&lt;p&gt;During my undergraduate years in Penn State, one of the project I have worked on is using FPGA to do an image processing at real time. The goal of the project was to feed in video stream from a camera and be able to do edge filtering with it at real time. My motivation for this project was two fold: one, I’ve read some articles online that there were some delay issues with performing image processing at the application level and two, I was extremely interested in computer vision at the time. Anyhow, this is the results of the project.&lt;/p&gt;

&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;
&lt;p&gt;Repository: &lt;a href=&quot;https://github.com/saw235/VHDL&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;figure class=&quot;video_container&quot;&gt;
  &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Z--MAIgVxYw&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/figure&gt;

&lt;p&gt;Because the path delay of the DSP-components easily exceeds the timing contraints, a finite state machine was used to pipeline the 2D-convolution process.&lt;/p&gt;

&lt;p&gt;The base images (girl and parrot) are loaded into seperate ram blocks. A 12-bit bus width is used for the ram due to the 12-bits VGA RGB ports of the Nexys4 board. A depth of 30000 is used to store a 200x150 px image.&lt;/p&gt;

&lt;p&gt;Several filters such as edge-filter, sobel, gaussian blur, emboss are implemented. They can be selected using the switches located at the bottom of the board.

From right to left, the seven segment digit shows which filter the 1st stage is using, which filter the 2nd stage is using, and which image the two filter is applied on. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/fpga-min.jpg&quot; alt=&quot;Nexys4 DDR Board hooked up with a VGA display&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;ImageText&quot;&gt; Unfiltered Parrot / Identity Filter &lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Parrot1-min.jpg&quot; alt=&quot;Unfiltered Parrot&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;ImageText&quot;&gt; Parrot with Edge filter &lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Parrot2-min.jpg&quot; alt=&quot;Filtered Parrot&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;ImageText&quot;&gt; Parrot after Blur and Edge Filter &lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Parrot3-min.jpg&quot; alt=&quot;Filtered Parrot&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;ImageText&quot;&gt; With girl image &lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Girl1-min.jpg&quot; alt=&quot;Unfiltered girl&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Girl2-min.jpg&quot; alt=&quot;Unfiltered girl&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;ImageText&quot;&gt; &lt;p&gt;With overlay image. Easily implemented by simply using a few AND and OR gates.&lt;/p&gt;&lt;p&gt;
See &lt;a href=&quot;https://en.wikipedia.org/wiki/Mask_(computing)#Image_masks&quot;&gt;https://en.wikipedia.org/wiki/Mask_(computing)#Image_masks&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Girl3-min.jpg&quot; alt=&quot;Unfiltered girl&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;implementaion-details&quot;&gt;Implementaion details&lt;/h2&gt;
&lt;p&gt;Here I have included the diagrams that I thought are important to understand the implementations of the project. There are specific things like datapath of the controller units, and actual top level implementation that are left out, but those can be easily understood by going over the VHDL codes.&lt;/p&gt;

&lt;h3 id=&quot;top-level-explained&quot;&gt;Top Level Explained&lt;/h3&gt;

&lt;p&gt;The image below shows the Top Level overview of the filter implementation.
The entire process is fairly straightforward. From the left, the diagram shows the Image being serialized from hardcoded rom, shifted into the kernel filter for processing. The output is then loaded into a buffer and starts another filtering process and finally is outputted in VGA format.&lt;/p&gt;

&lt;p&gt;A buffer is not needed but is utilized to simplify the process of two stages filtering. For example, the filters can be implemented directly to filter twice as the pixels are accumulated. The complexity involved, however, may be too much and impractical to implement.&lt;/p&gt;

&lt;p&gt;As a seperate functionality, an additionaly image stored in rom can also be overlaid on top of the rom images by performing some simple operations.
The details can be read &lt;a href=&quot;https://en.wikipedia.org/wiki/Mask_(computing)#Image_masks&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Pg1_Top Level Overview.jpg&quot; alt=&quot;Top Level Overview&quot; class=&quot;imgfilterdiagrams&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;image-filtering-implementation-explained&quot;&gt;Image Filtering Implementation Explained&lt;/h3&gt;

&lt;p&gt;The three images below shows the implementation behind the sliding window image filtering method.&lt;/p&gt;

&lt;p&gt;The first image shows the simplified idea of the entire process, whereas the second image shows the implementation of the sliding window in actualty.&lt;/p&gt;

&lt;p&gt;You can see in this image that the 9 pixel data shifted in forms a 3x3 window. When implementing this, I included the FIFO as part of the window component so that the whole thing consist of only two components: the top part and the bottom part.&lt;/p&gt;

&lt;h4 id=&quot;filtering-using-a-sliding-3x3-kernel&quot;&gt;Filtering using a sliding 3x3 kernel&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Pg2_Filtering Overview.jpg&quot; alt=&quot;Filtering Overview&quot; class=&quot;imgfilterdiagrams&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;actual-implementation&quot;&gt;Actual Implementation&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Pg3_Implementation Overview.jpg&quot; alt=&quot;image-title-here&quot; class=&quot;imgfilterdiagrams&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The third image shows the convolution unit. In practice, this doesn’t work 100% of the time and introduces some bugs due to timing constraints caused by the DSP components (much to my dismay). To avoid that, it is necessary to implement pipelining to perform the multiplication and summation by stages. You can look up on how to do pipelining easily in VHDL by googling for it or simply uses a (Finite State Machine) FSM and think of each operation as a state. My implementation uses a FSM.&lt;/p&gt;

&lt;h4 id=&quot;convolution-unit&quot;&gt;Convolution Unit&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Pg4_Convolution Unit.jpg&quot; alt=&quot;image-title-here&quot; class=&quot;imgfilterdiagrams&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;filter-controller&quot;&gt;Filter Controller&lt;/h3&gt;

&lt;p&gt;The last two images show the FSM of the controller which figures out when to start processing, when convolve the pixels, when to roll over and when to finish.&lt;/p&gt;

&lt;p&gt;Again, some of the states are redundant and can be combined but are seperated for clarity and easier implementation and debugging.&lt;/p&gt;

&lt;p&gt;Do remember that each of the state uses up at least one clock cycle (if no loop), however, and thus introduces delays. If your specific application is a hard real time system (ie, you need the image to be filtered within a specific amount of time), then it might not meet the requirement of the system. The same thing can be said for the pipelining process of the convolution unit.&lt;/p&gt;

&lt;p&gt;What you can do at this point is to either increase the clock frequency of the board and deal with a more stringent timing requirements, or come out with a quicker algorithm which requires less clock cycle to complete a full filtering process.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/Pg5_FSM KernelFilter_3x3.jpg&quot; alt=&quot;image-title-here&quot; class=&quot;imgfilterdiagrams&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/StateTable.PNG&quot; alt=&quot;image-title-here&quot; class=&quot;imgfilterdiagrams&quot; /&gt;&lt;/p&gt;
</summary>
      <id>http://saw235.github.io/2017/12/30/fpga-image-processing/</id>
      <updated>2017-12-30T20:00:00+08:00</updated>
      <author>
        <name>Xue Zheng</name>
      </author>
    </entry>
  
    <entry>
      <title>Capacitive CPAP Mask Programming</title>
      <link href="http://saw235.github.io/2017/12/30/cap-cpap-mask/" />
      <summary type="html">&lt;p&gt;Towards the end of my undergrad in Penn State Behrend, we had to do a senior design class in order to graduate. We were given the choice to pick from the projects that we liked but ultimately the project that were given to us were up to the discretion of our professors and the project sponsors, usually companies from the industries.&lt;/p&gt;

&lt;p&gt;Anyway, the project I and my team were given is a prototype for the CPAP mask with capacitive sensors on it. A sensing controller samples data from each of the sensors. Another microcontroller then polls the samples and process the samples (ie: performs calibration, encodes the samples and output serially etc. …)&lt;/p&gt;

&lt;p&gt;&amp;lt;/div&amp;gt; 
&lt;/p&gt;

&lt;div class=&quot;CPAP_IMG&quot;&gt;
&lt;p&gt;&lt;img src=&quot;/hikari/img/project_img/CPAP.jpg&quot; alt=&quot;CPAP&quot; /&gt;
&lt;img src=&quot;/hikari/img/project_img/CPAP1.jpg&quot; alt=&quot;CPAP1&quot; /&gt;
&lt;img src=&quot;/hikari/img/project_img/CPAP2.jpg&quot; alt=&quot;CPAP2&quot; /&gt;
&lt;img src=&quot;/hikari/img/project_img/CPAP3.jpg&quot; alt=&quot;CPAP3&quot; /&gt;
&lt;img src=&quot;/hikari/img/project_img/CPAP4.jpg&quot; alt=&quot;CPAP4&quot; /&gt;
&lt;img src=&quot;/hikari/img/project_img/CPAP5.jpg&quot; alt=&quot;CPAP5&quot; /&gt;

&lt;p style=&quot;font-size: 100%; font-family: sans-serif;&quot;&gt;The GUI is developed entirely using PyQt5. The new style signal and slots mechanism makes the implementations relatively quick and easy. The GUI has a serial listener thread that asynchronously reads data from the microcontroller.&lt;/p&gt;
&lt;img class=&quot;CPAP_GUI&quot; src=&quot;/hikari/img/project_img/CPAPGUI.PNG&quot; alt=&quot;GUI&quot; /&gt;
&lt;img class=&quot;CPAP_GUI&quot; src=&quot;/hikari/img/project_img/Putty.PNG&quot; alt=&quot;Terminal&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;
</summary>
      <id>http://saw235.github.io/2017/12/30/cap-cpap-mask/</id>
      <updated>2017-12-30T20:00:00+08:00</updated>
      <author>
        <name>Xue Zheng</name>
      </author>
    </entry>
  
</feed>
